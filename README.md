# SE

- [x] 软件生命周期
- [x] 软件过程模型、优缺点（记一下瀑布模型的阶段）
- [ ] 模块的概念、区分模块的要素
- [ ] 耦合内聚
- [ ] IPO图、层次图、DFD图的使用阶段、作用，描述
- [ ] CMM五级 每级的特点
- [ ] 黑盒测试、白盒测试
- [ ] 软件和程序的区别

# DB

（杭电好像教的是SqlServer）

## 什么是事务、ACID、怎么定义事务
   - 所谓事务是用户定义的**一个数据库操作序列**,这些操作要么全做,要么全不做,是一个不可分割的工作单位。
   - 原子性Atomicity：事务是数据库的逻辑工作单位,事务中包括的诸操作要么都做,要么都不做
   - 一致性Consistency：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。当数据库**只包含成功事务提交的结果时**,就说数据库处于**一致性状态。**如果数据库系统运行中发生故障,有些事务尚未完成就被迫中断,这些**未完成的事务对数据库所做的修改有一部分已写入物理数据库**,这时数据库就处于一种**不正确的状态**,或者说是不一致的状态。**一致性与原子性是密切相关的。**
   - 隔离性Isolation：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的,并发执行的各个事务之间不能互相干扰。
   - 持续性Durability：持续性也称永久性( Permanence),指一个事务一旦提交,它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。
   - 用BEGIN TRANSACTION开始事务，COMMIT和ROLLBACK表示事务结束。

## 索引的作用
   - 索引是数据结构，使用索引的全部意义就是通过缩小一张表中需要查询的记录**/**行的数目来加快搜索的速度。
   - 常用数据结构
     - B+树索引：B+树索引是将索引属性组织成B+树形式,B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。
       - 什么时候用：一列属性经常作为
         - 查询条件
         - 聚集函数参数
         - 连接条件
     - Hash索引：散列索引是建立若干个桶,将索引属性按照其散列函数值映射到相应桶中,桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。
       - 什么时候用
         - 一个关系大小可以预知且不变
         - 关系大小动态改变，但DBMS提供了动态Hash存取方法
     - 位图索引：位图索引是用位向量记录索引属性中可能出现的值,每个位向量对应一个可能值
     - 聚簇存取：把属性上具有相同值的元组集存放在连续的物理块中
       - 什么时候用
         - 经常在连接的关系可以建立聚簇
         - 一组属性值经常出现在想等比较的条件中
         - 属性重复率很高

## 并发机制有哪些、怎么实现、并发会引起什么问题？
   - 并发机制
     - 封锁（见4）
     - 时间戳：在每一个事务上加一个时间戳，表示事务开始的时间，每个事务具有唯一的时间戳并按照时间戳来解决事务的冲突操作，如果发生冲突操作，就回滚具有较早时间戳的事务，保证其他事务的正常执行，被回滚的事务被赋予新的时间戳并从头执行。
     - 乐观控制法：认识事务执行的过程中很少发生冲突，让事务自由之行而不对其进行特殊的管制，事务提交前再检查正确性，如果发现出现过冲突，并影响了可串行性，就拒绝并回滚。
     - 多版本并发控制：在数据库中通过维护数据对象的多个版本信息来实现高效并发控制。好处是消除了数据库中数据对象读写操作的冲突，提高了系统的性能。坏处是会产生大量无效版本，在事务结束的时刻，其影响的元组的有效性不能马上确定。
   - 并发引起的问题
     - 丢失修改：两个事务T1和T2读入同一数据并修改,T2提交的结果破坏了T1提交的结果,导致T1的修改被丢失。
     - 不可重复读：不可重复读是指事务T读取数据后,事务T2执行更新操作,使T1无法再现前一次读取结果。（**数据读取后被修改**）
       - T1先读，T2修改了数据，T1再次读，读到了不同的数据
       - T1先读，T2删除了数据，T1再次读，读不到数据
       - T1先读，T2插入了数据，T1再次读，读出了其他数据
     - 读脏数据：读“脏”数据是指事务T1修改某一数据并将其写回磁盘,事务T2读取同一数据后T1由于某种原因被撤销,这时被T修改过的数据恢复原值,T2读到的数据就与数据库中的数据不一致,则T2读到的数据就为“脏”数据,即不正确的数据。（**数据读取后遭到回滚**）

## DB中有哪些锁、各自作用、举例说明
   - 排他锁（X锁，写锁）：若事务T对数据对象A加上X锁,则只允许T读取和修改A, **其他任何事务都不能再对A加任何类型的锁,直到T释放A上的锁为止。**这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。
   - 共享锁（S锁，读锁）：若事务T对数据对象A加上S锁,**则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁为止。**这就保证了其他事务可以读A,但在T释放A上的S锁之前不能对A做任何修改。
   - 封锁协议
     - 一级封锁协议：**事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。**一级封锁协议可防止丢失修改,并保证事务T是可恢复的（保证有人在写的时候其他人写不了）。
     - 二级封锁协议：在一级封锁协议基础上增加事务T在读取数据R之前必须先对其加S锁,**读完后即可释放S锁。**二级封锁协议除防止了丢失修改,还可进一步防止读“脏”数据（保证有人在写的时候其他人读不了）。
     - 三级封锁协议：三级封锁协议是指,在一级封锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁,**直到事务结東才释放**。三级封锁协议除了防止丢失修改和读“脏”数据外,还进一步防止了不可重复读（保证读完后在数据不用前别人写不了）。

     - 锁的状态（详见操作系统）
       - 活锁（饥饿）：可以使用先来先服务策略避免饥饿
       - 死锁
         - 预防
           - 一次封锁：一个事物只能在开始时一次性把需要的所有数据都加上锁。
           - 顺序封锁：只能按照特定的顺序实施封锁
         - 检测与解除：超时法和资源分配图法

## DB中的存储过程和函数

   - 存储过程：存储过程是由过程化SQL语句书写的过程,这个过程经编译和优化后存储在数据库服务器中,因此称它为存储过程,使用时只要调用即可。

     - 创建

       ```sql
       CREATE PROCEDURE delete_matches(IN p_playerno INTEGER)
       BEGIN
       　　DELETE FROM MATCHES
          WHERE playerno = p_playerno;
       END;
       ```

     - 调用：CALL 过程名

     - 优点

       - 由于存储过程不像解释执行的SQL语句那样在提出操作请求时才进行语法分析和优化工作,因而**运行效率高,它提供了在服务器端快速执行SQL语句的有效途径**。
       - 存储过程**降低了客户机和服务器之间的通信量**。客户机上的应用程序只要通过网络向服务器发出调用存储过程的名字和参数,就可以让关系数据库管理系统执行其中的多条SOQL语句并进行数据处理。只有最终的处理结果才返回客户端
       - (3)方便实施企业规则。可以把企业规则的运算程序写成存储过程放入数据库服务器中,由关系数据库管理系统管理,既有**利于集中控制,又能够方便地进行维护**。当企业规则发生变化时只要修改存储过程即可,无须修改其他应用程序
     
   - 函数：函数和存储过程类似,都是持久性存储模块。函数的定义和存储过程也类似,不同之处是**函数必须指定返回的类型**

     ```sql
     CREATE FUNCTION 函数名([参数1,参数2,…])  RETURNS<类型> 
     AS <过程化SQL块>
     ```

     

## 数据库设计的流程

   - 需求分析：通过调查获取用户对数据的信息要求、处理要求、安全性与完整性要求
     - 数据字典（见软件工程）
   - 概念结构设计：E-R模型是用E-R图来描述现实世界的概念模型。
   - 逻辑结构设计：概念结构是独立于任何一种数据模型的信息结构,**逻辑结构设计的任务就是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。**
   - 物理结构设计：为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程
   - 数据库实施：数据库实施阶段包括两项重要的工作,一项是数据的载入,另一项是应用程序的编码和调试。
   - 数据库运行和维护：在数据库运行阶段,对数据库经常性的维护工作主要是由数据库管理员完成的。
     - 转储和恢复
     - 安全性、完整性控制、
     - 性能监督、分析和改造
     - 数据库重组织和重构造

## E-R图的转换原则

- 一个实体型转换为一个关系模式，实体的属性就是关系的属性，实体的码(关键字)就是关系的码。

- 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选键。如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。

- 一个1:n联系可以转换为一个独立的关系模式，也可以与任意n端对应的关系模式合并。如果转换为一个独立的模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。如果与n端实体对应的关系模式合并，则需要在该关系模式的属性中加入1端关系模式的码和联系本身的属性

- 一个m:n联系转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。

- 三个以上实体间的一个多元联系可以转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。
  

## DBA是什么，作用？

   - DBA是数据库管理员
   - 作用
     - 决定数据库中的信息内容和结构。（**存什么**）
     - 决定数据库的存储结构和存取策略（**怎么存**）
     - 定义数据的安全性要求和完整性约束条件（**保证安全性和完整性**）
     - 监控数据库的使用和运行。
     - 数据库的改进和重组、重构

## 视图


  - **视图是从一个或几个基本表（或视图）导出的表。它与基本表不同,是一个**虚表**。数据库中**只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以**一旦基本表中的数据发生变化，从视图中査询出的数据也就随之改变了**。视图一经定义,就可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图,但对视图的**更新操作则有一定的限制。**

   - 视图的作用
     - 简化用户操作
     - 以多种角度看待同一数据
     - 对重构数据库提供了逻辑独立性
     - 对机密数据提供安全保护
     - 清晰得表达查询

## 关于数据库完整性约束（主、外键）

- 实体完整性：关系模型的实体完整性在 CREATE TABLE中用 PRIMARY KEY定义，代表主键，指的是一个列或多列的组合，其值能唯一地标识表中的每一行，通过它可强制表的实体完整性。

- 参照完整性：关系模型的参照完整性在 CREATE TABLE中用 FOREIGN KEY短语定义哪些列为外码,用 REFERENCES短语指明这些外码参照哪些表的主码。如果[公共关键字](https://baike.baidu.com/item/公共关键字/1239575)在一个关系中是[主关键字](https://baike.baidu.com/item/主关键字/1239455)，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的[相关](https://baike.baidu.com/item/相关/9882881)联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。

  - 检查和违约处理
    - 拒绝NO ACTION
    - 级联CASCADE
    - 设置空值

- 用户自定义完整性

  - 属性上的约束条件

    - NOT NULL
    - UNIQUE
    - CHECK短语（CHECK (sex in ('男','女'))）

  - 元组上的约束条件

    - 写在CHREATE TABLE后面 

```sql
CONSTRAINT C1 CHECK (sex in ('男','女'))
```

- 保证完整性的其他机制

  - 断言

```sql
CREATE ASSERTION asse_sc_db_num 
CHECK (60 >= (
SELECT COUNT(*) 
FROM course INNER JOIN sc ON sc.cno = course.cno
WHERE course.cname = '数据库'
))
```

- - 触发器：触发器( trigger)是用户定义在关系表上的一类由事件驱动的特殊过程。

- ```sql
  CREATE TRIGGER upd_check BEFORE UPDATE ON account
  FOR EACH ROW
  BEGIN
  IF NEW.amount < 0 THEN
  SET NEW.amount = 0;
  ELSEIF NEW.amount > 100 THEN
  SET NEW.amount = 100;
  END IF;
  END;
  ```


## 数据库权限

- 在自主存取控制方法中,用户对于**不同的数据库对象有不同的存取权限,不同的用户对同一对象也有不同的权限,而且用户还可将其拥有的存取权限转授给其他用户。**因此自主存取控制非常灵活。

- 用户权限

- 数据库模式

| 对象   | 操作类型                 |
| ------ | ------------------------ |
| 模式   | CREATE SCHEMA            |
| 基本表 | CREATE TABLE,ALTER TABLE |
| 视图   | CREATE VIEW              |
| 索引   | CREATE INDEX             |

- 数据

| 对象         | 操作类型                                                     |
| ------------ | ------------------------------------------------------------ |
| 基本表和视图 | SELECT, INSERT, UPDATE,DELETE,  REFERENCES, ALL     PRIVILEGES |
| 属性列       | SELECT, INSERT, UPDATE, REFERENCES, ALL PRIVILEGES           |

- 角色：数据库角色是被命名的一组与数据库操作相关的权限,角色是权限的集合。

# 编译原理

## 编译过程分为哪几个阶段？哪些阶段必不可少？
## C语言的编译过程

- 源文件(.c)是文本文件，经过预处理器进行简单的替换和预处理后送入编译器，编译器将该文件编译成与机器指令对应的汇编程序（依然是文本文件），再送入汇编器汇编，得到可重定位的目标程序（二进制文件），目标程序与C语言的库函数经过链接器的链接后，得到了装入模块（.exe）,最后被操作系统装入内存，得到执行。

# 数据结构

## 四种存储结构各有什么特点？
   -  数据结构由逻辑结构、存储结构和数据的运算构成
   - 逻辑结构
     - 集合结构：结构中的数据元素之间除了同属于一种类型外，无其他关系。
     - 线性结构：结构中的数据元素之间存在一对一的关系。
     - 树形结构：结构中的数据元素之间存在一对多的关系。
     - 图状结构或是网状结构：结构中的数据元素之间存在多对多的关系。
   - 存储结构
     - 顺序：元素物理上连续，所以可以随机存取、会产生外部碎片，容易访问但不容易增删
     - 链式：元素在物理上不连续，用指针逻辑连续，指针占用额外空间，但没有碎片问题，不容易访问但容易增删
     - 索引：把物理上非连续的元素组织到一张索引表中，例如静态链表、OS中的FAT表、相当于在顺序和链式存储中找一个平衡，较链表比较容易查询（索引表连续），较顺序容易增删
     - 散列：用计算的方式得到元素的存储地址，检索、增删的速度都很快，但散列函数如果设计不好就会产生冲突，使之访问效率退化（与冲突处理方式有关，如果是拉链法就退化到链式、如果是开放定址就退化到顺序表）
   - 数据的运算

## 链式存储和顺序存储的区别，优缺点比较，插入过程
   - 线性表
     - 特点
       - 逻辑上相邻的两个元素在物理位置上也相邻
       - 随机访问（在常数时间内找到指定下标的元素）
       - 结点内只需要存储元素本身，存储密度高（100%）
       - 插入和删除元素，需要移动相邻元素，开销很大，所以适合用于存储访问多但修改少的数据
       - 预先分配了空间，之后就不能修改了
     - 插入过程
       - 检查表是否已满
       - 从表尾开始到插入下表所指元素逐个后移
       - 存入给定元素
   - 链表
     - 特点
       - 不要求逻辑上相邻的元素在物理上也相邻
       - 访问效率低下（o(n)）
       - 存储密度没有线性表高，除了元素本身还需要存储指针
       - 插入和删除开销低，只需要修改相邻元素的指针即可
       - 空间的分配与回收灵活
     - 插入元素
       - 先将给定元素的pre和next指针连到原链表对应元素上（保证不丢指针）
       - 再将原链表上相邻元素的pre和next指针分别指向给定元素

## 二叉树和度为2的树的区别
   - 度为2要求一个树中必须有至少一个节点的度是2，即只空树、只有一个根结点的树、根结点+一个孩子的树是二叉树但不是度为2的树
   - 二叉树的孩子有严格的次序之分，即左右子树的次序不能随意颠倒。但在度为2的树中，若一个节点只有一个孩子，则没有左右孩子的区别。

## 线索二叉树概念

   - 利用空指针加快查找前驱后继节点的速度，二叉树的每个节点种包含ltag和rtag表示其所指向的是子节点还是前驱后继。注意后续遍历是无法通过线索化找到后继的。

## 哈夫曼树

   - 带权路径长度最小的二叉树
   - 特点：只有度为m和度为0（叶子）的节点
   - 可以用来构造最短二进制前缀编码（没有一个编码是另一个编码的前缀PFC）

## 图的存储方式

   - 邻接矩阵
     - 用一维数组保存顶点信息，二维数组保存对应下标的两个顶点之间是否有边
     - 便于查找两个顶点之间是否有边，但是难于计算图中边的个数。
     - 适合存储稠密图
   - 邻接表
     - 把与该顶点的出边相连的所有顶点接成一个链表（如果把所有入边相连的顶点串成链表，则称为逆邻接表）。顶点中保存一个指针表示第一个相邻顶点，组织成顶点表。
     - 难于确定两个顶点之间是否有边，但可以很方便找一个顶点的所有邻边。
     - 适合存储稀疏图
   - 十字链表
     - 结合邻接表和逆邻接表，以便同时查找与结点关联的入边和出边
     - 用于有向图（因为无向图不区分入边和出边）
   - 邻接多重表
     - 解决了邻接表表示有向图时一条边保存两次的问题
     - 用于有向图

## 图的遍历方式、DFS和BFS是什么、工程上有什么运用？

   - BFS：广度优先搜索，以V为起点，由近到远访问与v有路径想通的顶点（路径长度按序递增）
     - 用来求单源最短路径
   - DFS：深度优先遍历，一直深入直到不能继续再回退。需要借助递归栈
     - 用来拓扑排序
   - 都可以用来判断图的连通性

## 最小生成树的两种算法，优缺点比较、时间复杂度、有什么应用？

   - Prim算法：本质上是将端点集做一个划分，划分成已经选择的和未选择的部分，初始情况下将源点加入已选择的集合，其余顶点则都在未选择的集合中。算法的迭代过程是逐步在未选择顶点中选择与已选择顶点之间存在边且权值最小的顶点的过程（贪心算法），一旦所有顶点都被选择，算法即结束了。
     - 由算法的执行过程可以看出，Prim算法是一个不断选择顶点的过程，在整个算法的执行过程中，需要对图的顶点集合进行反复搜索，整个算法的性能只与顶点数量有关，为O(V^2)，即整个算法的性能与边的数量无关，因此非常适合边稠密的图
   - Kruskal算法：一开始将单独的顶点视为一个集合，搜索所有边得到权值最小（可以用小根堆）且两个端点不在同一集合中的边，将两个顶点所在集合合并（通过并查集实现），直到所有顶点都在一个集合中，算法就结束了。
     - Kruskal算法是一个不断选择边的过程，在算法执行的过程中需要对所有边进行反复搜索，整个算法性能只和边的数量有关，为O(ElogE)，适合用于边稀疏的图

## 最短路径算法，狄杰斯特拉和弗洛伊德的区别、分别适用于什么情况？

   - Djkstra算法：单源最短路径，即求出从给定的顶点开始，到其他所有顶点的最短路径。该算法本质上也是一种BFS（BFS引入parent数组，可以算出不带权的最短路径），只是将标准BFS中用于表示先后次序的队列换成了小根堆（保证权值最小路径的顶点得到访问），在结点入队前先计算其经过正在访问结点的路径是否缩短，仅当缩短时才队。

     - 用途：OSPF算路由表

     ```python
     import heapq
     import math
     
     def init_dist(graph, s):
       dist = {s: 0}
       for vtx in graph:
         if vtx != s:
           graph[vtx] = math.inf
       return dist
       
     
     def dijkstra(graph, s):
       pq = [] # 小根堆
       heapq.heappush(pq, (0,s))
       visited = set() # 已访问结点
       parent = {s: None} # 该结点的父节点
       dist = init_dist(graph, s) # 与源点的路径长度
     
       while(len(pq) > 0):
         pair = heapq.heappop(pq)
         dist = pair[0]
         vtx = pair[1]
         visited.add(vtx)
         adj_vtx = graph[vtx].keys()
     
         for v in adj_vtx:
           if v not in visited: # 被重复添加的结点其相邻的结点必然都被访问过 所以对结果不产生影响
             if dist + graph[vtx][v] < dist[v]:
               heapq.heappush(pq, (dist + graph[vtx][v],v))
               parent[v] = vtx
               dist[v] = dist + graph[vtx][v]
     
       return parent, dist
     ```

     - Floyd算法：本质上是一个动态规划算法
     
       - 状态转移方程：f(i,j,k) = min{ f(i,j,k-1), (f(i,k,k-1) + f(k,j,k-1))}` 其中`f(i,j,k)`表示用前k个顶点作为媒介，顶点i到j的最短路径长度。上式的意思是，对于路径`(i,j)`而言，要么中间点k被加入，要么k不加入（很像0-1背包问题）
       
         - k不加入，最短路径就是以前`k-1`个顶点作为媒介时的最短路径
         - k加入，则最短路径就是前`k-1`个顶点作为媒介时，`i到k的最短路径长度` + `k到j的最短路径长度`
       
       - 实现1，使用三维数组
       
         ```c
         void floyd_original()  {  
           for(int i=1;i<=n;i++)  
             for(int j=1;j<=n;j++)  
               d[0][i][j]=graph[i][j]; // 初始状态就是邻接矩阵
           for(int k=1;k<=n;k++)  
             for(int i=1;i<=n;i++)  
               for(int j=1;j<=n;j++)  
                 d[k][i][j]=min(d[k-1][i][j],d[k-1][i][k]+d[k-1][k][j]);  
         }  
         ```
       
       - 实现2，滚动数组：观察状态转移方程`f(i,j,k) = min{ f(i,j,k-1), (f(i,k,k-1) + f(k,j,k-1)) }`，实际上第k次迭代的结果只与k-1次的结果有关，并且凡是和 k 节点相连的边，在第 k 阶段的值都不会变（相当于经过k结点本身），因此根本没必要把所有结果都存下来。
       
         ```c
         void floyd() {  
           for(int i=1;i<=n;i++)  
             for(int j=1;j<=n;j++)  
               d[0][i][j]=graph[i][j]; // 初始状态就是邻接矩阵
           for(int k = 1; k <= n; k++)  
             for(int i = 1; i <= n; i++)  
               for(int j = 1; j <= n; j++)  
                 d[i][j] = min(d[i][j], d[i][k] + d[k][j]);  
         }  
         ```
     
     - 两者区别
     
       - 一个是单源最短路，一个是每对顶点的最短路。
       - 迪杰斯特拉属于贪心算法，弗洛伊德属于动态规划
       - 迪杰斯特拉不能算有负权的，弗洛伊德可以算有负权的。
       - 时间复杂度不同，O(n2),O(n3)

## 怎么确定图中有环

- 拓扑排序
	1. 遍历邻接表，统计每个结点的入度，将所有入度为0的结点入队
  2. 若队非空就出队，删除该结点的整个邻接表，并把相关的顶点入度都-1，遇见入度为0的结点继续入队
	3. 重复2
- 一次DFS或BFS，检查是否有重复访问的节点
  
    - 并查集检查是否可能出现两个同根节点的并

## 关键路径和关键活动分别是什么、什么情况下才有关键路径

- 关键路径是AOE网上，从源点到汇点的所有路径中，具有最大路径长度的路径
- 关键路径上的所有活动都是关键活动， 它是决定整个工程的关键因素，可以通过加快关键活动来缩短整个工期。但是也不能任意缩短，因为一旦缩短到一定的程度，该关键活动就可能变成非关键活动了
- 只有为关键路径所共有的关键活动加速且在不改变关键路径的前提下，才能缩短工期
- 延长关键活动必然导致工期延长

## 树和图遍历的区别

- 树可以视为图，树的层次遍历等价于对这棵树进行广度优先搜索
  
## B树与B+树的区别

|                            m阶B树                            |                    m阶B+树                     |
| :----------------------------------------------------------: | :--------------------------------------------: |
|                    m个关键字对应m+1个分叉                    |              m个关键字对应m个分叉              |
|                   所有结点中都包含记录信息                   |         只有最底层叶子结点包含记录信息         |
| 不支持顺序查找，查找成功的时候可以停在任意一层结点，查找速度不稳定 | 支持顺序查找，查找成功、失败都会达到最下层结点 |

## 构造哈希表的方法，Hash表的特点、有哪些散列函数、如何处理冲突、影响hash表平均查找长度的因素

   - 哈希表，是根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。（适合存储键值对）
   - 特点
     - 访问速度很快：通过计算的方法直接得到要访问元素的地址
     - 需要额外的空间：Hash表一般来说是存不满的，而且随着Hash表存的越满（装填因子大），冲突的概率会提高，进而访问速度会下降。
     - 无序：存入的元素不能保证原有的顺序
     - 会产生哈希冲突
   - 散列函数
     - 直接定址法：H(key) = key 或 H(key) = a * key +b
     - 除留余数法：表长m则取p为不超过m的最大质数，H(key) = key % p
     - 数字分析法：取数码分布均匀的若干位作为散列地址
     - 平放取中法：取平方值的中间几位
   - 处理冲突的方法
     - 开放定址法：可存放新表项的空闲地址既向同义词开发，又向非同义词开放（特别注意如果这样处理冲突，删除的时候能直接删除元素，而是做上一个删除标记）
       - 线性探测：线性增量序列
         - 容易导致相邻的散列地址被同义词聚集而降低查找效率
       - 平方探测：1^2、-1^2、2^2、-2^2
         - 不能探测到所有单元
       - 再散列
       - 伪随机序列
     - 拉链法：适用于经常插入和删除的情况

   - 影响ASL的因素

     - ASL直接依赖于装填因子即 $\alpha=\frac{表中记录个数}{散列表长度}$

     - $\alpha$越大表示散列表越满发生

## 排序中几种排序算法的实现过程、时间复杂度，哪些算法的最坏和平均时间复杂度是一样的、最好和最坏是一样的？


|   算法   |       最好        |       平均        |       最坏        |   空间    | 稳定 | 输入敏感 |
| :------: | :---------------: | :---------------: | :---------------: | :-------: | :--: | :------: |
| 直接插入 |      $O(n)$       |     $O(n^2)$      |     $O(n^2)$      |  $O(1)$   |  T   |    T     |
|   希尔   |         /         |         /         |         /         |  $O(1)$   |  F   |    T     |
|   冒泡   |      $O(n)$       |     $O(n^2)$      |     $O(n^2)$      |  $O(1)$   |  T   |    T     |
|   快速   |   *$O(nlogn)$*    |    $O(nlogn)$     |    *$O(n^2)$*     | $O(logn)$ |  F   |    T     |
| 简单选择 |     $O(n^2)$      |     $O(n^2)$      |     $O(n^2)$      |  $O(1)$   |  F   |    F     |
|  堆排序  |    $O(nlogn)$     |    $O(nlogn)$     |    $O(nlogn)$     |  $O(1)$   |  F   |    F     |
|   归并   |    $O(nlogn)$     |    $O(nlogn)$     |    $O(nlogn)$     |  $O(n)$   |  T   |    F     |
|   基数   | $O(d\times(n+r))$ | $O(d\times(n+r))$ | $O(d\times(n+r))$ |  $O(r)$   |  F   |    F     |

   

# 组成原理

## Cache的映射方法，有什么优缺点

1. 全相联：把主存地址划分为标记和块内地址两个部分，主存块可以随意放在Cache的任何位置，使用相联存储器按内容访问的特性可以直接得到Cache中标记相同行的内容，特点是不存在Cache空间浪费，标记位比较速度比较慢，硬件复杂，成本很高。
2. 直接映射：把主存地址划分为标记、行号和块内地址三个部分，通过行号和Cache行的大小可以计算出主存块在Cache中的地址，然后取出标记进行比较。特点是主存块只能装入Cache中的唯一位置，可能会产生冲突，且空间利用率比较低。
3. 组相联：组间直接映射，组内全相联结合了全相联和直接映射的的优点

## 简述在一个请求式页式带有块表和1级cache的存储系统中，一次访存的全过程

- 地址变换
  - 从虚地址中取出页号，先在TLB中查询，如果命中则得到实页号
    - 如果不命中，则需要访问页表，检查虚页号所对应的页表项的有效位是否为1，如果为1，同样得到实页号
      - 否则处理缺页异常，关中断 保存断点引出 中断处理程序 保存运行环境 开中断
        - 检查页表中是否有空页面，如果有则直接将虚地址所指块调入内存
          - 否则根据替换算法选择一个页面进行替换
        - 更新页表
      - 关中断 恢复现场 开中断 返回断点
    - 将虚地址转化为实地址并更新TLB
- Cache
  - 检查该物理地址所对应的主存块是否在cache中，如果在则直接读取，结束访存
    - 否则cache缺失，检查cache中是否存在空行，如果有空行则将内存块读出后送到cache
      - 若没有空行则根据替换算法替换cache中的块

## CPU有哪几种设计方式

- 硬布线
  - 整体思路是通过指令的操作码字段、当前机器周期、时钟节拍信号和机器的状态条件直接由硬件电路生成当前街拍下应该发出哪些为命令。（**微操作控制信号由组合逻辑电路即时产生**）
  - 指令越多，设计和实现就越复杂，因此一般用于RISC
  - 如果扩充一条新指令，整个控制器的设计可能需要大改，因此扩充指令很困难
  - 使用纯硬件实现控制，执行速度很快
- 微程序
  - 微操作信号以微程序的形式存放在CM中，执行指令的时候读出即可，不需要即使通过物理电路形成微操作控制信号
  - 微程序形成的过程
    - 机器指令的操作码字段送入微地址形成部件形成部件生成微程序的首地址
    - 顺序逻辑根据微指令的寻址特征字段、时钟周期和程序状态字将微指令在CM中的地址送入CMAR
    - CMAR中的地址经过译码后送入控存，控存按地址取出微指令送入CMDR
    - CU根据CMDR中的微指令的操作码字段将控制信号送至CPU内部或系统的控制总线
    - 顺序逻辑根据下地址字段生成下一条微指令的地址
- 微指令的设计
  - 操作码
    - 水平：一条指令对应好几个互斥的微操作
      - 编码方式
        - 直接编码
        - 字段直接编码
        - 字段间接编码
    - 垂直：一条指令对应一个微操作
  - 微地址的形成方法
    - 由下地址直接给出
    - 由操作码经过地址形成部件形成（首地址）
    - 增量计数法：CMAR+1
    - 测试网络



## cpu 和外设之间数据交换有哪几种，串行通信和并行通信

- 程序查询方式
  - CPU启动I/O后，就循环检查状态标记（I/O是否就绪），直到就绪后才进行数据的交换
  - 一旦启动I/O就必须停止先行程序的运行，CPU与I/O无法并行工作，大量的时间都被用来查询等待，效率低下，只适合于慢速设备
- 程序中断方式
  - CPU请求I/O后不必轮询等待，而是继续当前任务，直到I/O设备准备完成，向CPU发出中断请求后才响应中断，从而消除了忙等。
    - 对于外中断，只在当前指令执行结束后才进行相应
    - 对于内中断（OS里叫程序异常）可以在指令执行的过程中进行响应
  - 中断处理的过程
    - 中断隐指令
      - 关中断：保证保存断点的过程不被打断
      - 保存断点：把PC压入系统栈中
      - 引出中断服务程序：得到中断服务程序的入口地址
        - 硬件向量法（注意区别概念中断向量=中断处理程序的内存地址、中断向量地址=中断向量在中断向量表中的地址=中断类型号）
          - 中断向量地址形成部件形成了中断类型号
          - 读出中断向量表中的向量地址
          - 送入PC
        - 软件查询法
    - 中断服务程序
      - 保护现场：保存通用寄存器和状态寄存器的内容
      - 开中断
      - 中断服务：完成中断服务的业务
      - 关中断
      - 恢复现场：恢复被保存的CPU现场
      - 开中断
      - 中断返回：将原先执行程序的地址从系统栈中弹出写入PC
  - 多重中断：在执行中断服务程序前打开中断，使中断服务程序中可以嵌套其他中断
    - 中断屏蔽字：中断优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为‘0’，对新中断开放），如果是的话，就中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理
- DMA方式
  - DMA控制器可以在没有CPU干预的情况下接管数据总线的控制权，进而完成一个DMA传送块的传输。
  - DMA过程
    - 接受外设发出的DMA请求，并向CPU发出总线请求
    - CPU响应总线请求，发出总线响应信号，DMA控制器接管总线控制权，进入DMA操作周期
    - DMA控制器确认传送数据的单元地址和长度，并自动修改主存地址计数和传送长度计数，规定数据在主存和外设之间的数据传送方向，发出读写控制信号，执行数据传送操作
    - 向CPU报告DMA操作结束
  - DMA传送方式：DMA工作时需要占用数据总线，如果DMA与CPU同时访问主存会导致冲突，因此需要以下三种方式来避免冲突
    - 停止CPU访问内存：直接在DMA工作的时候禁止CPU访存
    - DMA与CPU交替访存：把一个存取周期对半分，一半给DMA一半给CPU。好处是不需要申请总线的使用权，没有建立和归还的过程，坏处是太慢了
    - 周期挪用：在DMA准备访存的时候，根据CPU当前的状态有不同的处理方式
      - CPU当前没在访存：没冲突
      - CPU正在访存：CPU在当前存取周期结束后让出总线
      - CPU正准备访存：I/O优先，CPU等DMA访存结束后再访存
- I/O通道方式：CPU发出I/O命令后，指明通道程序在内存中的位置，由通道执行I/O操作，直接将数据读入内存中，结束后向CPU发出中断请求。（通道是一个小处理机，一个通道可以接管多个设备，可以读取一组离散的块）



## 串行通信和并行通信

- 并行通信：并行通信传输中有多个数据位，同时在两个设备之间传输。发送设备将这些数据位通过对应的数据线传送给接收设备，还可附加一位数据校验位。接收设备可同时接收到这些数据，不需要做任何变换就可直接使用。并行方式主要用于**近距离通信**。计算机内的总线结构就是并行通信的例子。这种方法的优点是传输速度快，处理简单。

- 串行通信：串行数据传输时，数据是一位一位地在通信线上传输的，先由具有几位总线的计算机内的发送设备，将几位并行数据经并--串转换硬件转换成串行方式，再逐位经传输线到达接收站的设备中，并在接收端将数据从串行方式重新转换成并行方式，以供接收方使用。串行数据传输的速度要比并行传输慢得多，但对于**覆盖面极其广 阔**的公用电话系统来说具有更大的现实意义。
- **并行总线一定比串行的快是错误的**，因为并行总线如果工作频率过高会导致并行的线路之间的干扰，所以其频率往往不能取太高。事实上，往往高速的总线表中都采用的都是串行总线（PCIE、USB）

# 操作系统

## 操作系统有哪些功能？简述操作系统的四个特征

- 操作系统的功能
  - 资源管理
    - 处理机管理
    - 内存管理
    - 文件管理
    - 设备管理
  - 提供接口
    - 命令接口
    - 程序接口
- 四个特征
  - 并发：宏观上同时执行程序，但微观上轮流执行，通过分时共享处理器的原理实现。（注意与并行的区别）
  - 共享：系统中的资源可供多个并发执行的进程共同使用。与并发互为彼此的存在条件，两者均为操作系统的基本特征。
  - 虚拟：把物理实体抽象为逻辑上的对应物
    - 时分复用——时间片调度
    - 空分复用——虚拟存储器
  - 异步：多道程序并发执行并各自以不可预知的速度推进。操作系统需要保证多次运行进程后得到相同的结果。

## 实时系统和分时系统各有哪些特点

- 分时系统：把处理器运行时间分成很短的时间片，按时间片轮流把处理器分配给各个作业使用。是操作系统并发性的实现方式，同时也是虚拟性的体现（实际只有一个处理机，但却好像同时服务了不同的作业）。分时系统很好的解决了人机交互的问题，使得多个用户通过中断同时共享一台主机。
  - 同时性
  - 交互性
  - 独立性
  - 及时性
- 实时系统：为了解决某时间限制内完成某些紧急任务而不需要时间片排队而产生。
  - 硬实时系统：硬实时系统是某个动作必须绝对地在规定的时刻发生
  - 软实时系统：统能接受偶尔违反时间规定且不会引起永久性的损害

## 简述中断有哪些类型，其与OS内核两种状态的联系

- 两类中断
  - 内中断（异常）：与当前执行的指令相关
    - 自愿中断
      - 陷入（trap）：程序因为请求资源而阻塞
    - 强迫中断
      - 硬件故障（abort）：掉电
      - 软件中断（falut）：除0、缺页
  - 外中断（中断）：与当前执行的指令无关（例如键盘、鼠标的输入）
- OS内核的两种状态
  - 用户态：用户程序在用户态中执行，不能使用特权指令，当产生中断时，将切换到核心态（中断时让OS夺回CPU使用权的唯一途径）
    - 读诗中、取数、寄存器清零
  - 核心态：内核程序运行在核心态下、可以执行特权指令（中断返回指令是特权指令）

## 什么是系统调用？什么情况下内核会从用户态切换为核心态？

- 系统调用：用户在程序中调用了操作系统提供的一些自功能。（一般来说用户程序要使用与资源相关的功能都需要通过系统调用）
- 以下情况会从用户态切换为核心态
  - 系统调用
  - 中断
    - 缺页、除0（内中断）
    - DMA请求（外中断）

## 进程和程序有什么区别？进程在操作系统中是如何组织的？进程有什么特点？

- 进程与程序的关系
  - 进程是程序在一个数据集合上的一次运行过程，是动态的、过程性的。
- 进程的组织方式：进程=代码段+数据+PCB
- 进程的特点
  - 动态性：进程是程序的一次执行过程。
  - 并发性：多个进程同时存在与内存中，并能并发运行（引入进程的目的）
  - 独立性：进程能独立运行、独立获得资源和接受调度
  - 异步性：进程之间相互制约、按照独立不可预知的速度推进
  - 结构性：每个进程都由一个PCB描述（代码段+数据+PCB）

## 进程之间如何进行通信？

- 低级通信：广义上，进程的同步和互斥的就是一种通信，所以PV操作是通信方式
- 高级通信
  - 共享存储
    - 基于数据结构
    - 基于存储区：在内存中维护一个共享存储区，用于存放进程的消息，并用PV操作实现互斥
  - 消息传递
    - 消息队列：把格式化消息挂在消息队列
    - 信箱通信：通过把格式化消息放入内存中的信箱
  - 管道通信
    - 管道是一种共享文件、半双工、不能同时读写、具有仅当读空才能写、写满才可读的特点

## 线程和进程有什么区别？线程有哪些实现方式？

- 线程与进程的区别
  - 线程是处理机调度的最小单位，进程是资源分配的最小单位。
  - 进程拥有资源、线程不拥有资源
    - 线程可以访问其所属进程的资源
    - 线程没有独立的地址空间
    - 同一进程内切换线程开销很小、可以进一步提升系统的并发度
- 线程的实现方式
  - 用户级线程：线程库，早期OS不支持多线程，很多人实现了自己的线程库，这种情况下OS不知道线程的存在，切换线程不需要变态、开销小。但是线程一阻塞整个进程就阻塞了，用户级线程是代码逻辑的载体
  - 内核级线程：由OS实现的线程、OS知道线程的存在、切换线程需要变态、并发能力强但是开销大于用户级线程、内核级线程是运行机会的载体。

## 处理机调度由哪三个级别？有哪些调度算法？

- 处理机调度的三个级别（七状态模型：就绪挂起、阻塞挂起）
  - 高级调度（作业调度）：从后备队列选择合适的作业调入并为其创建进程(外存->内存，无->创建态->就绪态)
  - 中级调度（内存调度）：从挂起队列中选择合适进程将其数据调回内存（外存->内存，挂起态->就绪态）
  - 低级调度（进程调度）：从就绪队列中选择一个进程为其分配处理机（内存->CPU，就绪态->运行态）
- 调度算法
  - 先来先服务：对长作业（CPU繁忙）型作业有利、短作业（IO繁忙）型作业不利、只考虑等待时间
  - 短作业优先：对长作业（CPU繁忙）型作业不利、短作业（IO繁忙）型作业有利、只考虑运行时间。会产生饥饿
  - 优先级调度：适合用于实时系统，会产饥饿现象
  - 高响应比优先：等待时间当分子，服务时间当分母，兼顾了等待和执行时间、解决了饥饿问题
  - 时间片轮转：分时系统的基础
  - 多级反馈队列：队列优先级递减、前面FCSC最后时间片、只有前面的队列空才执行后面的队列、前面的队列可以随时抢占后面的队列

## 进程同步的基本原则

- 空闲让进
- 忙则等待
- 优先等待
- 让权等待

## 有哪些方法保证临界区的互斥访问？

- 软件方法：flag数组表示想进、turn变量表示让步
  - 单标志：只有turn，两个进程只能交替进入邻接去
  - 双标志先检查：可能导致两个进程同时进入邻接去
  - 双标志后检查：可能导致死锁
  - 皮特森算法
- 硬件方法
  - 中断屏蔽：直接在硬件层面屏蔽中断，只适合单处理机、效率低下
  - TestAndSet指令
  - Swap指令

## 如何在读者写者问题中保证读者与写者的公平？

- 增加一个信号量用来保证当读者试图读的时候，若有写者正在等待或写，则先让读者进入等待队列直到写者完成后才开始读。

## 死锁有哪些处理策略？

- 死锁预防——破坏四个必要调侃
  - 互斥访问
  - 请求并保持
  - 不剥夺
  - 循环等待
- 死锁避免：在分配资源前通过一定的算法（银行家算法）判断当前资源请求是否会造成死锁，找到安全序列后才可以分配
- 死锁检测：发生死锁后OS进行检测并通过资源剥夺、撤销进程和回退等手段解除死锁

## 什么是链接？什么是装入？分别有哪几种形式？

- 链接：把目标代码块与库函数链接成一个完整的装入模块的过程
  - 静态链接：在程序运行之前，先把各个目标模块和库函数链接为一个完整的可执行程序
  - 装入时动态链接：在目标代码块装入内存时，才与库函数链接
  - 运行时动态链接：在程序运行时才进行链接，可执行文件需要附带一个动态链接库（DLL），在执行的时候需要调用对应动态链接库中的命令。
- 装入：装入程序将装入模块装入内存中运行
  - 绝对装入：编译后产生的目标模块就包含最终运行时的绝对地址，只能用于单道程序，换一台电脑就需要重新编译
  - 可重定位装入（静态重定位）：编译后产生的目标模块包含的是逻辑地址，在装入时根据OS分配的起始地址计算出物理地址。
  - 动态运行时装入（动态重定位）：只有在程序运行的时候，才根据基址寄存器计算出物理地址，支持非连续分配方式和动态申请内存。

## 解释一下什么叫覆盖、什么叫交换

- 覆盖：把一个进程分为固定区和覆盖区，前者存放程序经常活跃的部分，后者将剩余的程序进行按需调入
- 交换：其实就是中级调度，将内存中不活跃的部分挂起，交换到磁盘的对换区

## 有哪些内存分配方式？

- 连续
  - 单一连续
  - 固定连续
  - 动态连续
    - 首次适应
    - 最佳适应
    - 最坏适应
    - 临近适应
- 非连续
  - 页式
  - 段式
  - 段页式

## 分页式内存管理和分段式内存管理有什么区别？

对于非连续分配管理方式，根据分区的大小是否固定氛围分页式和分段式管理

- 分页存储：以页为物理单位进行内存分配，页大小固定且由系统确定，逻辑地址空间是一维的，只产生内部碎片。分页存储对用户透明，目的是为了实现离散内存分配，提高内存利用率。
- 分段存储：以段为逻辑单位进行内存分配，段长度不固定，逻辑地址是二维的（需要通过段号和段内地址才能得到具体存储地址），只产生外部碎片，对用户不透明，需要用户指定程序的分段方式，更容易实现信息的共享和保护

## 有哪些页面置换算法？

- 最佳置换算法：替换掉未来最久不被使用到的算法，实际是无法实现的 拥有最好的性能
- 先进先出算法：先被调入的页面先被换出，实现简单，但可能出现belady异常（驻留集增大缺页率反而增大）
- 最近最长时间未使用算法LRU：优先淘汰最久没被使用的页面，性能好，但需要硬件的支持，开销大
  - 计数器法：给页表中的每一页增加一个域，专门用来存放计数器，页面每被访问一次，计数器 0，其余的+1，要装入新页时，从内存的页面中选出计数器最大的一页，调出。
- Clock算法：为了解决LRU算法的开销问题，引入了环形缓冲区，新调入的页面或者刚被访问的页面使用位被设置为1，替换时扫描环形缓冲区，遇到1则设置为0，遇到0则替换。这样做的好处是，在保证先进先出的基础上替换掉没被使用过的页面。
- 改进的Clock算法：不仅有使用位还增加了修改位，整个算法的思想就是在保证先进先出和优先淘汰未使用页面的基础上优先淘汰未被修改的页，因为修改过的页面在替换之前要写回磁盘，所以应该尽量避免替换。

## 什么叫驻留集？什么叫工作集？

- 驻留集：给一个进程分配的物理页框的集合
- 工作集：一定时间内，进程使用过的页框的集合

## 有哪些页面分配策略？

- 固定分配局部置换：给一个进程分配的页框数一旦确定就不更改了，发生缺页不给其分配新页框而是在进程已有的页框中进行置换
- 可变分配全局置换：给进程分配的页面不够用的时候，从系统维护的全局空闲页面中给其分配新的页面
- 可变分配局部置换：允许给一个进程分配新的页面，但仅在其频繁缺页（抖动）时才分配新页面，一般情况下只在进程已有的页框中进行置换

## 什么是文件系统？

文件系统是操作系统中中文件管理有关的软件和数据的集合

- 实现按名存取文件信息
- 为用户提供统一友好的接口
- 实施对文件和文件目录的管理
- 文件存储器空间的分配与回收
- 提供有关文件的共享和保护

## 文件的逻辑结构有哪些

- 无结构文件（流式文件）

- 有结构文件（记录式文件）

  - 顺序文件
    - 按是否有序
      - 串结构
      - 顺序结构
    - 按物理结构
      - 链式
      - 顺序
  - 索引文件：将文件分成索引表和文件记录两个部分，目的是让变长记录也可以顺序访问
  - 索引顺序文件：将文件记录按照关键字进顺序进行分组，保持组间有序，索引表为每组的第一项建立索引

  ## 操作系统怎么实现文件共享？

  - 硬链接：文件目录中只设置文件名和指向相应索引结点的指针，索引结点中维护一个链接计数器，表示链接到本索引结点上的目录项数，删除文件仅在计数器为0时才删除索引结点和文件本身，否则只删除目录项目。（目录项=FCB）
  - 软链接：符号连接是一种特殊的文件，其保存着真实文件的路径，只有文件的拥有者才拥有指向索引结点的指针，其他共享者拥有的是符号连接文件。

## 文件的物理结构有哪些

- 连续分配
  - 每个文件在磁盘上占有一组连续的块
  - 支持随机访问、难于扩展文件
  - 产生外部碎片
- 链接分配
  - 隐式链接：除了最后一块外，每块都有指向下一块的指针，便于扩展文件，没有外部碎片，无法随机访问
  - 显式链接：对整个文件系统建立一张FAT表，记录盘块对策次序，在逻辑块号映射成物理块号的过程中不读盘，支持随机访问，没有外部碎片且便于扩展。
- 索引分配：为每个文件都建立一张索引表，FCB中维护一个指向索引块的指针
  - 一级索引
  - 多级索引
  - 混合索引

## 存储空间管理的方法有哪些？

- 空闲表法：用一张空闲盘块表记录
- 空闲链表法：将空闲盘块维护成链表
- 位示图法：每一个二进制位对应一个盘块
- 成组链接法

## 有哪些磁盘调度算法？

- 先来先服务
- 最短寻道时间优先SSTF：每次把磁头移动到距离最近的请求磁道，会产生饥饿
- 电梯算法SCAN：必须将磁头移动到最边上才可以调头，即使没有请求也要移动到最边缘，越靠边的请求越容易被响应
- LOOK算法：如果一侧已经没有更多请求了则可以直接调头
- C-SCAN：只能响应一个方向上的请求的SCAN算法
- C-LOOK：同上

## 磁盘如何初始化？开机后如何将操作系统读入内存？

- 初始化
  - 物理格式化：将磁盘分成扇区，并将扇区分为头、尾和数据区
  - 磁盘分区：将磁盘划分为文件卷（CDE）
  - 逻辑格式化：创建文件系统
- 读入操作系统
  - ROM中出厂内置了一个很小的自举装入程序，负责找到磁盘引导块中的自举程序，最后由自举程序找到操作系统并读入内存

## 什么是SPOOLING技术

- 将要输出到I/O设备的数据先输出到内存中的输入缓冲区，再经过输入进程的控制将数据输出到磁盘中的输出井上，最后由输出进程将输出井中的数据经过内存中的输出换存取输出到输出设备。
- 这样做的好处是，请求I/O操作的设备只需要将数据写到高速的磁盘中，就可以继续进行其余任务，而不是阻塞等待I/O操作的完成，将一个物理设备抽象成逻辑上的多台设备，是操作系统虚拟性的一个体现。

# 网络

## 计算机网络怎么定义？

计算机网络是将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。一般来说网络具有数据通信、资源共享、分布式处理、提高可靠性和负载均衡的作用。

## 计算机网络按照覆盖可以划分为什么？

- 广域网：覆盖范围大，是因特网的核心部分，连接广域网的各结点交换机的链路一般都是高速链路，有较大的通信容量。使用交换技术，是点对点网络。
- 城域网：在一个城市范围内建立的计算机通信网，采用以太网技术。
- 局域网：使用广播技术将各种设备通过高速线路相连，覆盖范围较小。
- 个域网：使用无线技术将个人的设备连接（直径10m）

## 计算机网络的拓扑结构有哪些？

- 总线型
- 星型
- 环形
- 网状

## OSI和TCP/IP有哪几层？每一层都有哪些设备？各自使用什么地址？

### OSI

- 物理层
  - 作用：在物理媒体上**透明地**传输**原始比特流**。规定接口参数和传输的信号意义以及电器特性、
  - 设备（物理层设备无法分割冲突域，半双工，不能连接两个具有不同速率的局域网）
    - 中继器：对信号进行再生和还原，对衰减信号进行放大，增强信号的传输距离，延长网络长度
    - 集线器：对信号进行再生放大转发，不具备定向传送能力，是一个共享式设备
- 链路层（点到点=主机到主机）
  - 加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路.
    - 组装成帧：将网络层传来的IP数据包组装成帧。
    - 差错控制：检测出由于外界噪声干扰产生的比特流错误并丢弃相应的帧
    - 流量控制：协调两个链路层设备之间的传输速率使得两边都不至于丢弃来不及处理的帧。
    - 传输管理：控制共享信道的访问（MAC子层）
  - 协议
    - PPP
    - HDLC：面向比特、同步 
  - 设备
    - 网桥
    - 交换机
- 网络层
  - 主要功能：将分组从远端传送到目的端，为分组交换网上的不同主机提供通信服务
    - 路由选择：根据网络状况选择一条合适的路径使分组可以顺利到达目标结点
    - 流量控制：协调两个节点的发送速率
    - 拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况
    - 差错控制：用一定的规则检验目标结点接受到的数据与源结点发出的数据是否一致，若不一致则要么纠正要么丢弃
    - 网际互联：将大量异构网络通过路由器连接起来
  - 协议
    - IP
    - ICMP
    - IGMP
    - ARP
    - RARP
    - OSPF
  - 设备
    - 路由器
- 传输层（端到端=进程到进程）
  - 功能：为端到端连接提供可靠的传输服务
    - 可靠传输（TCP）、流量控制、拥塞控制
    - 复用/分用：多个进程可以同时使用传输层的服务，传输层分别将收到的信息交付给上面的应用层的进程中
    - 链接管理
  - 协议
    - TCP
    - UDP
- 会话层：建立、管理进程间的会话（表示层实体或用户进程建立链接并在连接上有序的传输数据）
- 表示层：处理两个通信系统中信息的表示方式（编码形式、压缩、加密、解密）
- 应用层
  - 功能：用户与网络的界面。
  - 协议
    - HTTP
    - SMTP
    - FTP

### TCP/IP

- 网络接口层
- 网际层：面向无链接
- 传输层：面向连接（TCP）或者面向无链接（UDP）
- 应用层

## 有哪些数据交换的方式？

- 电路交换：源结点与目的结点之间有一条由中间结点构成的专用物理线路，线路一致保持到传输结束

  - 用户始终占用固定传输带宽，通信时延小，有序传输，不会争用物理信道

- 报文交换：数据交换的单位是报文，采用存储转发的方式，将不限长的报文从一个结点发送到另一个结点

  - 无需建立连接
  - 动态分配线路，如果两个断点之间的某条路径出现故障，可以选择换一条路径
  - 提高线路利用率，两个端点之间的线路并不是独占的，可以在传输期间传输其他用户的报文
  - 存储转发的过程会引入转发时延
  - 报文没有大小限制，需要比较大的缓存

- 分组交换：改进报文交换，要求每个报文具有固定的大小上限，简化了存储管理，可以用流水线的方式进行传输，减少了出错后重传的数据量

  ![image-20210316181822279](/Users/yangchang/Library/Application Support/typora-user-images/image-20210316181822279.png)

## 集线器、交换机和路由器有什么区别？

## 交换机能否用在大型网络中？

## 已经有交换机了，还需要CSMA/CD协议吗？

## 数据链路层的三个基本问题是什么？如何解决？

- 组装成帧：封装成帧就是在一段数据前后分别添加首部和尾部。接收端以便从收到的比特流中识别帧的开始与结束，帧定界是分组交换的必然要求；
  - 
- 透明传输：透明传输避免消息符号与帧定界符号相混淆；
- 差错检测：差错检测防止差错的无效数据帧，浪费网络资源。

## 什么是IP地址？什么是MAC地址？两者如何转换？

## 怎么解决IPv4地址不够用的问题？

## 路由是什么？路由器有什么作用？

## 路由表有哪些表项？

## 路由选择协议有哪些？

## 无线路由器怎么配置？

## 什么是BS？什么是CS？

## 传输层有什么协议？端口号分别是多少？

## TCP是靠什么实现可靠传输的？

## 有哪些流量控制的方法？缓存满了怎么调度？

## TCP怎么控制拥塞？怎么判断是不是拥塞？拥塞了怎么办？

## UDP有哪些应用？

## HTTP、FTP和WEB分别是什么？端口号是多少？

## 什么是网卡？

# 毕业设计

## Vue是怎么实现数据绑定的

实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。Observer里有Dep，Dep里的sub数组存放watcher。

实现一个解析器 Compile：解析  Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

![1.png](https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)